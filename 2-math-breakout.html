<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>üß± Math Breakout</title>
  <style>
    :root{
      --bg:#060b12;
      --panel: rgba(10,18,30,0.88);
      --accent:#00ff88;
      --accent2:#61a8ff;
      --danger:#ff4d4d;
      --text:#d7e7ff;
      --muted:#7f93ad;
      --shadow: rgba(0,0,0,0.4);
      --card:#0b1422;
      --border: rgba(120,160,210,0.22);
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html, body { height:100%; }
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 50% 10%, #0b1a33 0%, var(--bg) 55%, #04060a 100%);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden; /* important for iPad */
      touch-action:none; /* prevent scroll/zoom while dragging */
    }

    #wrap{
      position:fixed;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    /* Responsive game stage */
    #stage{
      width:min(980px, 100vw);
      height:min(720px, 100svh);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:10px;
      padding:10px;
    }

    #topbar{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius:12px;
      box-shadow: 0 10px 30px var(--shadow);
    }

    #brand{
      display:flex;
      flex-direction:column;
      gap:2px;
      line-height:1.05;
    }
    #brand .title{
      font-weight:900;
      letter-spacing:0.3px;
      font-size:14px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    #brand .title span.badge{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-weight:800;
      font-size:11px;
      color:#001a10;
      background: var(--accent);
      padding:2px 8px;
      border-radius:999px;
    }
    #brand .sub{
      font-size:11px;
      color:var(--muted);
    }

    #hud{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
      gap:8px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px;
      color:#cfe3ff;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(8,14,22,0.5);
      display:flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }
    .pill b{ color: var(--accent); }
    .pill .k{ color:#a9c6ff; }

    #gameArea{
      width:100%;
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      background: linear-gradient(180deg, rgba(10,18,30,0.65) 0%, rgba(6,9,18,0.85) 100%);
      border: 1px solid var(--border);
      border-radius:14px;
      box-shadow: 0 20px 50px var(--shadow);
      overflow:hidden;
    }

    canvas{
      display:block;
      width:100%;
      height:100%;
    }

    /* Overlays */
    .overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      background: rgba(0,0,0,0.60);
      backdrop-filter: blur(6px);
    }
    .overlay.show{ display:flex; }

    .card{
      width:min(560px, 92vw);
      background: rgba(10,18,30,0.92);
      border: 1px solid var(--border);
      border-radius:16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.55);
      padding:16px;
    }
    .card h1{
      margin:0 0 8px 0;
      font-size:18px;
      letter-spacing:0.2px;
    }
    .card p{
      margin:6px 0 0 0;
      color: var(--muted);
      font-size:12px;
      line-height:1.4;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-top:12px;
    }

    .btn{
      appearance:none;
      border:none;
      cursor:pointer;
      border-radius:12px;
      padding:12px 14px;
      font-weight:900;
      color:#001a10;
      background: var(--accent);
      box-shadow: 0 10px 18px rgba(0,255,136,0.18);
      min-width:140px;
    }
    .btn.secondary{
      background: rgba(10,18,30,0.25);
      color: var(--text);
      border: 1px solid var(--border);
      box-shadow:none;
      min-width:auto;
      font-weight:800;
    }
    .btn.danger{
      background: var(--danger);
      color:white;
      box-shadow: 0 10px 18px rgba(255,77,77,0.18);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:12px;
    }
    @media (max-width: 520px){
      .grid2{ grid-template-columns:1fr; }
      .btn{ width:100%; }
    }

    .select{
      width:100%;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background: rgba(6,10,16,0.5);
      color: var(--text);
      font-weight:800;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      outline:none;
    }

    .shopItem{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border: 1px solid var(--border);
      border-radius:14px;
      background: rgba(8,14,22,0.5);
      margin-top:8px;
    }
    .shopItem .meta{
      display:flex;
      flex-direction:column;
      gap:2px;
      font-size:12px;
    }
    .shopItem .meta .name{ font-weight:900; }
    .shopItem .meta .desc{ color:var(--muted); font-size:11px; }

    .shopItem .buy{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .tag{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      color:#cfe3ff;
      background: rgba(6,10,16,0.35);
      white-space:nowrap;
    }
    .tag.locked{ color:#ffc7c7; border-color: rgba(255,77,77,0.3); }

    .mathBox{
      margin-top:10px;
      padding:12px;
      border-radius:14px;
      border:1px solid var(--border);
      background: rgba(8,14,22,0.55);
    }
    .mathQ{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:18px;
      font-weight:900;
      letter-spacing:0.5px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    .mathQ .timer{
      font-size:12px;
      color: var(--muted);
      font-weight:800;
    }
    .answerRow{
      display:flex;
      gap:8px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    .ansBtn{
      flex:1;
      min-width:110px;
      padding:12px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background: rgba(6,10,16,0.35);
      color: var(--text);
      font-weight:900;
      cursor:pointer;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:14px;
    }
    .ansBtn:active{ transform: translateY(1px); }

    .hint{
      margin-top:8px;
      color: var(--muted);
      font-size:11px;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="stage">
      <div id="topbar">
        <div id="brand">
          <div class="title">üß± MATH BREAKOUT <span class="badge">ARCADE</span></div>
          <div class="sub">Clear bricks ‚Üí Math Rush ‚Üí buy upgrades (expire next level)</div>
        </div>
        <div id="hud">
          <div class="pill"><span class="k">Mode</span> <b id="hudMode">Addition</b></div>
          <div class="pill"><span class="k">Level</span> <b id="hudLevel">1</b></div>
          <div class="pill"><span class="k">Lives</span> <b id="hudLives">3</b></div>
          <div class="pill"><span class="k">Coins</span> <b id="hudCoins">0</b></div>
          <div class="pill"><span class="k">Best</span> <b id="hudBest">0</b></div>
        </div>
      </div>

      <div id="gameArea">
        <canvas id="c"></canvas>

        <!-- Start Overlay -->
        <div id="startOverlay" class="overlay show">
          <div class="card">
            <h1>Play Math Breakout</h1>
            <p>Touch/drag (iPad) or mouse to move the paddle. Clear all bricks to reach a Math Rush. Earn coins for upgrades that last only for the next level.</p>

            <div class="grid2">
              <div>
                <label style="font-size:11px;color:var(--muted);font-weight:800;">Math Mode</label>
                <select id="modeSelect" class="select" aria-label="Math mode">
                  <option value="add">Addition</option>
                  <option value="sub">Subtraction</option>
                  <option value="mul">Multiplication</option>
                  <option value="div">Division</option>
                </select>
                <div class="hint">Facts to 12. Division stays whole-number.</div>
              </div>
              <div>
                <label style="font-size:11px;color:var(--muted);font-weight:800;">Difficulty</label>
                <select id="diffSelect" class="select" aria-label="Difficulty">
                  <option value="1">Chill</option>
                  <option value="2" selected>Normal</option>
                  <option value="3">Fast</option>
                </select>
                <div class="hint">Faster ball + tighter paddle at higher difficulty.</div>
              </div>
            </div>

            <div class="row">
              <button class="btn secondary" id="btnHow">Controls</button>
              <button class="btn" id="btnStart">‚ñ∂ Start</button>
            </div>

            <p id="howText" style="display:none;margin-top:10px;">
              <b>Touch/Mouse:</b> drag anywhere inside the game area.<br>
              <b>Keyboard:</b> ‚Üê ‚Üí move ‚Ä¢ Space to launch ‚Ä¢ P to pause.
            </p>
          </div>
        </div>

        <!-- Shop / Math Rush Overlay -->
        <div id="shopOverlay" class="overlay">
          <div class="card">
            <h1 id="shopTitle">Math Rush</h1>
            <p id="shopSub">Answer as many as you can to earn coins. Then buy upgrades for the next level.</p>

            <div class="mathBox">
              <div class="mathQ">
                <div id="mathQuestion">8 + 2 = ?</div>
                <div class="timer">Time: <b id="rushTime">45</b>s</div>
              </div>
              <div class="answerRow" id="answerRow"></div>
              <div class="hint" id="mathHint">Tap an answer. Faster = more coins.</div>
            </div>

            <div style="margin-top:12px; font-size:12px; color:var(--muted);">
              Coins earned this rush: <b style="color:var(--accent);" id="rushCoins">0</b>
            </div>

            <div id="shopList" style="margin-top:10px;"></div>

            <div class="row">
              <button class="btn secondary" id="btnSkipShop">Skip</button>
              <button class="btn" id="btnNextLevel">Next Level ‚ñ∂</button>
            </div>

            <p style="margin-top:10px; font-size:11px; color:var(--muted);">
              Upgrades expire after you clear the next level.
            </p>
          </div>
        </div>

        <!-- Game Over Overlay -->
        <div id="gameOverOverlay" class="overlay">
          <div class="card">
            <h1>Game Over</h1>
            <p id="gameOverText">Nice run.</p>
            <div class="row">
              <button class="btn secondary" id="btnRestart">Restart</button>
              <button class="btn" id="btnBackToMenu">Main Menu</button>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Utilities =====
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const shuffle = (arr) => { for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; };

  // ===== DOM =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  const hudMode = document.getElementById('hudMode');
  const hudLevel = document.getElementById('hudLevel');
  const hudLives = document.getElementById('hudLives');
  const hudCoins = document.getElementById('hudCoins');
  const hudBest = document.getElementById('hudBest');

  const startOverlay = document.getElementById('startOverlay');
  const shopOverlay = document.getElementById('shopOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');

  const modeSelect = document.getElementById('modeSelect');
  const diffSelect = document.getElementById('diffSelect');
  document.getElementById('btnHow').onclick = () => {
    const t = document.getElementById('howText');
    t.style.display = (t.style.display === 'none') ? 'block' : 'none';
  };

  // ===== Persistent best =====
  const BEST_KEY = 'brainysheets_math_breakout_best';
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  hudBest.textContent = String(best);

  // ===== Game State =====
  const state = {
    running:false,
    paused:false,

    mode:'add', // add, sub, mul, div
    diff:2,     // 1 chill, 2 normal, 3 fast

    level:1,
    lives:3,
    coins:0,

    // upgrades apply only for NEXT level
    pendingUpgrades: {
      wide:false,
      slow:false,
      extraLife:false,
      multi:false
    },
    activeUpgrades: {
      wide:false,
      slow:false,
      multi:false
    },

    // controls
    pointerX:null,
    left:false,
    right:false,

    // physics
    ballLaunched:false,
    balls:[], // for multi-ball

    // bricks
    bricks:[],
    bricksRemaining:0,

    // rush
    inRush:false,
    rushTime:45,
    rushCoins:0,
    rushTimerId:null,

    // anti-repeat math
    lastQs: []
  };

  // ===== Layout / Scaling =====
  function resize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize, { passive:true });

  // ===== Entities =====
  const paddle = {
    x: 0, y: 0,
    w: 120, h: 16,
    speed: 10
  };

  function makeBall(x,y,vx,vy){
    return { x, y, r: 7, vx, vy, alive:true };
  }

  // ===== Level Generation =====
  function buildBricks(level) {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width;
    const H = rect.height;

    const rows = clamp(4 + Math.floor((level-1)/2), 4, 9);
    const cols = clamp(8 + Math.floor((level-1)/3), 8, 13);

    const pad = 10;
    const top = 18;
    const gap = 6;

    const totalGapW = gap*(cols-1);
    const usableW = W - pad*2 - totalGapW;
    const brickW = Math.floor(usableW / cols);
    const brickH = 18;

    const bricks = [];
    const colors = [
      '#61a8ff','#00ff88','#ffd166','#ff7a59','#c77dff','#00d1ff'
    ];

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        // simple patterns: skip some bricks in higher levels
        const skipChance = (level >= 4) ? 0.08 + (level-4)*0.01 : 0.0;
        if (Math.random() < skipChance) continue;

        const x = pad + c*(brickW+gap);
        const y = top + r*(brickH+gap);

        const hp = (level >= 6 && r < 2) ? 2 : 1; // tougher top rows later
        bricks.push({
          x, y, w: brickW, h: brickH,
          hp,
          color: colors[(r + level) % colors.length]
        });
      }
    }
    state.bricks = bricks;
    state.bricksRemaining = bricks.length;
  }

  function applyPendingUpgradesToActive() {
    // Active only for the level you are about to play
    state.activeUpgrades.wide = state.pendingUpgrades.wide;
    state.activeUpgrades.slow = state.pendingUpgrades.slow;
    state.activeUpgrades.multi = state.pendingUpgrades.multi;

    // consume pending (extraLife is immediate)
    state.pendingUpgrades.wide = false;
    state.pendingUpgrades.slow = false;
    state.pendingUpgrades.multi = false;
  }

  function resetPaddleAndBall() {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width;
    const H = rect.height;

    const diff = state.diff;
    const baseW = (diff === 1) ? 150 : (diff === 2 ? 125 : 110);
    paddle.w = baseW * (state.activeUpgrades.wide ? 1.35 : 1.0);
    paddle.h = 16;
    paddle.y = H - 36;
    paddle.x = (W - paddle.w)/2;

    const speedBase = (diff === 1) ? 5.0 : (diff === 2 ? 6.2 : 7.3);
    const speed = speedBase * (state.activeUpgrades.slow ? 0.82 : 1.0);

    state.balls = [ makeBall(W/2, paddle.y - 14, speed, -speed) ];
    state.ballLaunched = false;
  }

  function startLevel() {
    applyPendingUpgradesToActive();
    buildBricks(state.level);
    resetPaddleAndBall();
    state.running = true;
    state.paused = false;
    state.inRush = false;
    shopOverlay.classList.remove('show');
    gameOverOverlay.classList.remove('show');
    startOverlay.classList.remove('show');
    updateHUD();
  }

  // ===== HUD =====
  function modeLabel(m){
    return m === 'add' ? 'Addition'
      : m === 'sub' ? 'Subtraction'
      : m === 'mul' ? 'Multiplication'
      : 'Division';
  }
  function updateHUD(){
    hudMode.textContent = modeLabel(state.mode);
    hudLevel.textContent = String(state.level);
    hudLives.textContent = String(state.lives);
    hudCoins.textContent = String(state.coins);
    hudBest.textContent = String(best);
  }

  // ===== Input (Touch/Mouse/Keyboard) =====
  function setPointerFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    const x = clientX - rect.left;
    state.pointerX = x;
  }

  const gameArea = document.getElementById('gameArea');
  gameArea.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    gameArea.setPointerCapture(e.pointerId);
    setPointerFromEvent(e);
    if (state.running && !state.inRush && !state.paused && !state.ballLaunched) state.ballLaunched = true;
  }, { passive:false });

  gameArea.addEventListener('pointermove', (e) => {
    if (e.pressure === 0 && e.pointerType !== 'mouse') return;
    e.preventDefault();
    setPointerFromEvent(e);
  }, { passive:false });

  gameArea.addEventListener('pointerup', (e) => {
    e.preventDefault();
    state.pointerX = null;
  }, { passive:false });

  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') state.left = true;
    if (e.key === 'ArrowRight') state.right = true;
    if (e.key === ' '){
      if (state.running && !state.inRush && !state.paused) state.ballLaunched = true;
    }
    if (e.key.toLowerCase() === 'p'){
      if (state.running && !state.inRush) state.paused = !state.paused;
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft') state.left = false;
    if (e.key === 'ArrowRight') state.right = false;
  });

  // prevent iOS double-tap zoom gesture inside game
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 250) e.preventDefault();
    lastTouchEnd = now;
  }, { passive:false });

  // ===== Math Generator (facts to 12) =====
  function makeQuestion(){
    const m = state.mode;
    let a,b,ans, text;

    // Keep trying until we get something not recently used
    for(let tries=0; tries<40; tries++){
      if (m === 'add'){
        a = randInt(0,12); b = randInt(0,12);
        ans = a + b;
        text = `${a} + ${b} = ?`;
      } else if (m === 'sub'){
        a = randInt(0,12); b = randInt(0,12);
        // make it non-negative more often
        if (b > a) [a,b] = [b,a];
        ans = a - b;
        text = `${a} ‚àí ${b} = ?`;
      } else if (m === 'mul'){
        a = randInt(0,12); b = randInt(0,12);
        ans = a * b;
        text = `${a} √ó ${b} = ?`;
      } else { // div whole-number
        b = randInt(1,12);
        ans = randInt(0,12);
        a = b * ans;
        text = `${a} √∑ ${b} = ?`;
      }

      const key = `${m}|${a}|${b}|${ans}`;
      if (!state.lastQs.includes(key)){
        state.lastQs.push(key);
        if (state.lastQs.length > 18) state.lastQs.shift();
        return { a,b,ans,text };
      }
    }

    // fallback
    return { a:8,b:2,ans:10,text:'8 + 2 = ?' };
  }

  function buildAnswers(correct){
    const opts = new Set([correct]);
    while(opts.size < 4){
      const bump = randInt(-6, 6);
      const v = clamp(correct + bump, 0, 144);
      opts.add(v);
    }
    return shuffle([...opts]);
  }

  // ===== Rush + Shop =====
  const shopTitle = document.getElementById('shopTitle');
  const shopSub = document.getElementById('shopSub');
  const mathQuestionEl = document.getElementById('mathQuestion');
  const answerRow = document.getElementById('answerRow');
  const rushTimeEl = document.getElementById('rushTime');
  const rushCoinsEl = document.getElementById('rushCoins');
  const shopList = document.getElementById('shopList');

  let currentQ = null;

  function showShop() {
    state.inRush = true;
    state.rushCoins = 0;
    state.rushTime = 45;
    updateHUD();

    shopTitle.textContent = 'Math Rush';
    shopSub.textContent = 'Answer fast to earn coins. Then buy upgrades for the next level.';
    rushCoinsEl.textContent = '0';
    rushTimeEl.textContent = String(state.rushTime);

    shopOverlay.classList.add('show');
    currentQ = null;
    nextQuestion();

    if (state.rushTimerId) clearInterval(state.rushTimerId);
    state.rushTimerId = setInterval(() => {
      state.rushTime--;
      rushTimeEl.textContent = String(state.rushTime);
      if (state.rushTime <= 0){
        clearInterval(state.rushTimerId);
        state.rushTimerId = null;
        // Move to shop mode
        startShopPhase();
      }
    }, 1000);
  }

  function nextQuestion() {
    currentQ = makeQuestion();
    mathQuestionEl.textContent = currentQ.text;
    answerRow.innerHTML = '';
    const answers = buildAnswers(currentQ.ans);
    answers.forEach(v => {
      const btn = document.createElement('button');
      btn.className = 'ansBtn';
      btn.textContent = v;
      btn.onclick = () => handleAnswer(v);
      answerRow.appendChild(btn);
    });
  }

  function handleAnswer(v) {
    if (!state.inRush) return;
    if (state.rushTimerId === null) return; // already ended

    if (v === currentQ.ans){
      // reward: small combo feel
      const gain = 2; // coins per correct
      state.rushCoins += gain;
      rushCoinsEl.textContent = String(state.rushCoins);
      nextQuestion();
    } else {
      // tiny penalty: time loss
      state.rushTime = Math.max(0, state.rushTime - 2);
      rushTimeEl.textContent = String(state.rushTime);
      nextQuestion();
    }
  }

  function startShopPhase() {
    // add earned coins
    state.coins += state.rushCoins;
    updateHUD();

    shopTitle.textContent = 'Upgrade Shop';
    shopSub.textContent = 'Spend coins. Upgrades apply only to the next level.';
    mathQuestionEl.textContent = 'Rush complete ‚úÖ';
    answerRow.innerHTML = '';
    document.getElementById('mathHint').textContent = 'Buy upgrades below, then start the next level.';

    renderShopItems();
  }

  function renderShopItems() {
    const L = state.level;

    const items = [
      {
        id:'wide',
        name:'Wide Paddle',
        desc:'Bigger paddle next level.',
        cost: 10,
        unlock: 1
      },
      {
        id:'slow',
        name:'Slow Ball',
        desc:'Ball moves slower next level.',
        cost: 12,
        unlock: 2
      },
      {
        id:'multi',
        name:'Multi Ball',
        desc:'Start next level with 2 balls.',
        cost: 18,
        unlock: 4
      },
      {
        id:'life',
        name:'Extra Life',
        desc:'Gain +1 life now.',
        cost: 20,
        unlock: 3
      }
    ];

    shopList.innerHTML = '';
    items.forEach(it => {
      const locked = L < it.unlock;
      const wrap = document.createElement('div');
      wrap.className = 'shopItem';

      const left = document.createElement('div');
      left.className = 'meta';
      left.innerHTML = `<div class="name">${it.name}</div><div class="desc">${it.desc}</div>`;

      const right = document.createElement('div');
      right.className = 'buy';

      const tag = document.createElement('div');
      tag.className = 'tag' + (locked ? ' locked' : '');
      tag.textContent = locked ? `Unlock L${it.unlock}` : `${it.cost} coins`;

      const btn = document.createElement('button');
      btn.className = 'btn secondary';
      btn.textContent = locked ? 'Locked' : 'Buy';
      btn.disabled = locked;

      btn.onclick = () => {
        if (state.coins < it.cost) return;

        if (it.id === 'life'){
          state.coins -= it.cost;
          state.lives += 1;
        } else {
          // set pending upgrades
          if (it.id === 'wide') state.pendingUpgrades.wide = true;
          if (it.id === 'slow') state.pendingUpgrades.slow = true;
          if (it.id === 'multi') state.pendingUpgrades.multi = true;
          state.coins -= it.cost;
        }
        updateHUD();
        renderShopItems();
      };

      right.appendChild(tag);
      right.appendChild(btn);

      wrap.appendChild(left);
      wrap.appendChild(right);
      shopList.appendChild(wrap);
    });
  }

  document.getElementById('btnSkipShop').onclick = () => {
    // skip immediately to next level (but keep pending upgrades already bought)
    proceedToNextLevel();
  };
  document.getElementById('btnNextLevel').onclick = () => proceedToNextLevel();

  function proceedToNextLevel(){
    shopOverlay.classList.remove('show');
    state.inRush = false;

    // apply multi-ball if purchased
    startLevel();
    if (state.activeUpgrades.multi){
      const rect = canvas.getBoundingClientRect();
      const W = rect.width;
      const speedBase = (state.diff === 1) ? 5.0 : (state.diff === 2 ? 6.2 : 7.3);
      const speed = speedBase * (state.activeUpgrades.slow ? 0.82 : 1.0);
      // add a second ball with slightly different angle
      state.balls.push( makeBall(W/2 + 18, paddle.y - 14, -speed, -speed) );
    }
  }

  // ===== Game Over =====
  function showGameOver() {
    state.running = false;
    state.inRush = false;
    if (state.rushTimerId) { clearInterval(state.rushTimerId); state.rushTimerId = null; }
    shopOverlay.classList.remove('show');

    const score = state.level - 1;
    if (score > best){
      best = score;
      localStorage.setItem(BEST_KEY, String(best));
    }
    updateHUD();

    document.getElementById('gameOverText').textContent = `You reached Level ${state.level}. Best: ${best}.`;
    gameOverOverlay.classList.add('show');
  }

  document.getElementById('btnRestart').onclick = () => {
    // restart with same mode/diff
    state.level = 1;
    state.lives = 3;
    state.coins = 0;
    state.pendingUpgrades = { wide:false, slow:false, extraLife:false, multi:false };
    state.activeUpgrades  = { wide:false, slow:false, multi:false };
    startLevel();
  };
  document.getElementById('btnBackToMenu').onclick = () => {
    gameOverOverlay.classList.remove('show');
    startOverlay.classList.add('show');
  };

  // ===== Start Button =====
  document.getElementById('btnStart').onclick = () => {
    state.mode = modeSelect.value;
    state.diff = Number(diffSelect.value);
    state.level = 1;
    state.lives = 3;
    state.coins = 0;
    state.pendingUpgrades = { wide:false, slow:false, extraLife:false, multi:false };
    state.activeUpgrades  = { wide:false, slow:false, multi:false };
    state.lastQs = [];
    hudMode.textContent = modeLabel(state.mode);
    startLevel();
  };

  // ===== Physics + Collisions =====
  function circleRectCollide(ball, r){
    const cx = clamp(ball.x, r.x, r.x + r.w);
    const cy = clamp(ball.y, r.y, r.y + r.h);
    const dx = ball.x - cx;
    const dy = ball.y - cy;
    return (dx*dx + dy*dy) <= (ball.r*ball.r);
  }

  function update(dt){
    if (!state.running || state.paused || state.inRush) return;

    const rect = canvas.getBoundingClientRect();
    const W = rect.width;
    const H = rect.height;

    // paddle movement
    if (state.pointerX !== null){
      paddle.x = state.pointerX - paddle.w/2;
    } else {
      if (state.left) paddle.x -= paddle.speed;
      if (state.right) paddle.x += paddle.speed;
    }
    paddle.x = clamp(paddle.x, 8, W - paddle.w - 8);

    // balls
    for (const ball of state.balls){
      if (!ball.alive) continue;

      if (!state.ballLaunched){
        // stick to paddle center
        ball.x = paddle.x + paddle.w/2;
        ball.y = paddle.y - 14;
        continue;
      }

      ball.x += ball.vx;
      ball.y += ball.vy;

      // walls
      if (ball.x - ball.r < 0){ ball.x = ball.r; ball.vx *= -1; }
      if (ball.x + ball.r > W){ ball.x = W - ball.r; ball.vx *= -1; }
      if (ball.y - ball.r < 0){ ball.y = ball.r; ball.vy *= -1; }

      // paddle
      if (circleRectCollide(ball, paddle) && ball.vy > 0){
        ball.y = paddle.y - ball.r - 0.5;

        // angle based on hit position
        const hit = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
        const maxAngle = 0.9; // radians-ish scale
        const speed = Math.hypot(ball.vx, ball.vy);
        const angle = hit * maxAngle;

        ball.vx = speed * Math.sin(angle);
        ball.vy = -Math.abs(speed * Math.cos(angle));

        // tiny speed up over time
        const cap = (state.diff === 1) ? 8.2 : (state.diff === 2 ? 9.4 : 10.6);
        const newSpeed = Math.min(cap, speed * 1.01);
        const scale = newSpeed / speed;
        ball.vx *= scale; ball.vy *= scale;
      }

      // bricks
      for (const b of state.bricks){
        if (b.hp <= 0) continue;
        if (!circleRectCollide(ball, b)) continue;

        // reflect: choose axis based on penetration
        const prevX = ball.x - ball.vx;
        const prevY = ball.y - ball.vy;

        const wasLeft   = prevX < b.x;
        const wasRight  = prevX > b.x + b.w;
        const wasAbove  = prevY < b.y;
        const wasBelow  = prevY > b.y + b.h;

        if ((wasLeft && !wasAbove && !wasBelow) || (wasRight && !wasAbove && !wasBelow)){
          ball.vx *= -1;
        } else {
          ball.vy *= -1;
        }

        b.hp -= 1;
        if (b.hp <= 0){
          state.bricksRemaining--;
          // small coin drip for breaking bricks
          state.coins += 1;
          updateHUD();
        }
        break; // one collision per frame
      }

      // bottom out
      if (ball.y - ball.r > H + 20){
        ball.alive = false;
      }
    }

    // remove dead balls if multi
    const alive = state.balls.filter(b => b.alive);
    state.balls = alive.length ? alive : state.balls;

    const anyAlive = state.balls.some(b => b.alive);
    if (!anyAlive){
      state.lives--;
      updateHUD();
      if (state.lives <= 0){
        showGameOver();
        return;
      }
      resetPaddleAndBall();
    }

    // level complete
    if (state.bricksRemaining <= 0){
      // next level ‚Üí rush
      state.level++;
      updateHUD();
      showShop();
    }
  }

  // ===== Render =====
  function draw(){
    const rect = canvas.getBoundingClientRect();
    const W = rect.width;
    const H = rect.height;

    // background
    ctx.fillStyle = '#05070c';
    ctx.fillRect(0,0,W,H);

    // stars
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#cfe3ff';
    for(let i=0;i<40;i++){
      const x = (i*97 + (state.level*13)) % W;
      const y = (i*193 + (state.level*29)) % H;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    // bricks
    for(const b of state.bricks){
      if (b.hp <= 0) continue;
      ctx.fillStyle = b.color;
      ctx.fillRect(b.x, b.y, b.w, b.h);
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(b.x, b.y, b.w, 4);
      ctx.globalAlpha = 1;

      if (b.hp === 2){
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#000';
        ctx.fillRect(b.x+4, b.y+4, b.w-8, b.h-8);
        ctx.globalAlpha = 1;
      }
    }

    // paddle
    ctx.fillStyle = '#00ff88';
    ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(paddle.x, paddle.y, paddle.w, 4);
    ctx.globalAlpha = 1;

    // balls
    for(const ball of state.balls){
      if (!ball.alive) continue;
      ctx.beginPath();
      ctx.fillStyle = '#61a8ff';
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(ball.x - 2, ball.y - 2, Math.max(2, ball.r*0.35), 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // message
    if (state.running && !state.inRush && !state.paused && !state.ballLaunched){
      ctx.fillStyle = 'rgba(215,231,255,0.85)';
      ctx.font = '700 14px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.textAlign = 'center';
      ctx.fillText('Tap / Click / Space to launch', W/2, H*0.72);
      ctx.textAlign = 'left';
    }

    if (state.paused){
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#d7e7ff';
      ctx.font = '900 22px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Paused', W/2, H/2);
      ctx.font = '700 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillText('Press P to resume', W/2, H/2 + 22);
      ctx.textAlign = 'left';
    }
  }

  // ===== Loop =====
  let last = performance.now();
  function loop(t){
    const dt = (t - last) / 16.6667;
    last = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // ===== Init =====
  resize();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
